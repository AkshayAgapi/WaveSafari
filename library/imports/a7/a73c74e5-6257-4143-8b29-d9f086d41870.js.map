{"version":3,"sources":["../../../../assets/Script/assets/Script/BoatInputController.ts"],"names":[],"mappings":"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","file":"","sourceRoot":"../../../../assets/Script","sourcesContent":["import WaterBoundarySetting from \"../Data/WaterBoundarySetting\";\nimport Joystick from \"./Joystick/Joystick\";\n\nconst { ccclass, property } = cc._decorator;\n\n@ccclass\nexport default class BoatInputController extends cc.Component {\n\n    @property(WaterBoundarySetting)\n    waterBoundarySetting: WaterBoundarySetting = null;\n\n    @property(Joystick)\n    joystick: Joystick = null;\n\n    movementSpeed: number = 230.0; // Units per second\n    rotationSpeed: number = 200; // Degrees per second, adjusted for smoother transition\n    public currentVelocity: cc.Vec3 = cc.Vec3.ZERO; // Tracking current velocity for inertia\n    private targetRotation: number = 0;\n    private decelerationFactor: number = 0.993; // Factor to decrease velocity each frame when joystick is released\n    private idleTime: number = 0; // Time since last joystick input\n\n    // New properties for the ripple effect\n    public isIdle: boolean = false; // Is the boat idle?\n    private rippleMagnitude: number = 0.05; // Magnitude of the ripple effect\n    private rippleFrequency: number = 1; // Frequency of the ripple effect\n    \n    update(dt: number): void {\n        if (this.joystick && this.joystick.Joystick_Vector.mag() > 0) {\n            this.currentVelocity = this.joystick.Joystick_Vector.normalize().mul(this.movementSpeed);\n            this.idleTime = 0; // Reset idle time\n            this.isIdle = false;\n        } else {\n            this.currentVelocity.mulSelf(this.decelerationFactor);\n            this.idleTime += dt;\n            if (this.idleTime > 2) { // Wait for 1 second of inactivity to consider the boat idle\n                this.isIdle = true;\n            }\n        }\n\n        this.handleMovementAndInertia(dt);\n        this.handleRotation(dt);\n\n        if (this.isIdle) {\n            this.applyIdleRippleEffect(dt);\n        }\n    }\n\n    private applyIdleRippleEffect(dt: number): void {\n        // Apply a slight oscillation in position and rotation to simulate water ripples\n        const rippleOffset = Math.sin(this.idleTime * Math.PI * this.rippleFrequency) * this.rippleMagnitude;\n        const rippleRotation = Math.cos(this.idleTime * Math.PI * this.rippleFrequency) * this.rippleMagnitude;\n\n        this.node.position = this.node.position.add(cc.v2(rippleOffset, rippleOffset));\n        this.node.angle += rippleRotation;\n    }\n\n    private handleMovementAndInertia(dt: number): void {\n        if (this.joystick && this.joystick.Joystick_Vector.mag() > 0) {\n            // Update velocity based on joystick input\n            this.currentVelocity = this.joystick.Joystick_Vector.normalize().mul(this.movementSpeed);\n        } else {\n            // Apply inertia when the joystick is released\n            this.currentVelocity.mulSelf(this.decelerationFactor);\n        }\n        \n        // Calculate the new position based on the current velocity\n        const newPosition = cc.v2(this.node.position.x + this.currentVelocity.x * dt, this.node.position.y + this.currentVelocity.y * dt);\n        //if (this.waterBoundarySetting && this.waterBoundarySetting.boundaryRect.contains(newPosition)) {\n            this.node.position = newPosition;\n        //}\n    }\n    \n    private handleRotation(dt: number): void {\n        if (this.joystick && this.joystick.Joystick_Vector.mag() > 0) {\n            // Calculate the target rotation based on joystick input\n            this.calculateTargetRotation(this.joystick.Joystick_Vector);\n        }\n    \n        // Smoothly interpolate the boat's current rotation towards the target rotation\n        const currentAngle = this.node.angle;\n        const targetAngle = this.targetRotation;\n    \n        // Determine the shortest direction to rotate\n        const angleDifference = this.normalizeAngle(targetAngle - currentAngle);\n        const rotationDirection = angleDifference > 0 ? 1 : -1;\n    \n        // Calculate rotation amount based on rotation speed and deltaTime\n        let rotationAmount = this.rotationSpeed * dt;\n        \n        // If the absolute difference is less than what we would rotate this frame, clamp it\n        if (Math.abs(angleDifference) < rotationAmount) {\n            rotationAmount = Math.abs(angleDifference);\n        }\n    \n        // Apply rotation\n        this.node.angle += rotationAmount * rotationDirection;\n    }\n    \n\n    private calculateTargetRotation(direction: cc.Vec3): void {\n        const angle = direction.signAngle(cc.Vec2.RIGHT);\n        this.targetRotation = -cc.misc.radiansToDegrees(angle);\n    }\n    \n    private smoothRotation(dt: number): void {\n        const difference = this.normalizeAngle(this.targetRotation - this.node.angle);\n        const step = Math.min(Math.abs(difference), this.rotationSpeed * dt) * this.sign(difference);\n        this.node.angle += step;\n    }\n\n    private normalizeAngle(angle: number): number {\n        angle %= 360;\n        if (angle < -180) return angle + 360;\n        if (angle > 180) return angle - 360;\n        return angle;\n    }\n\n    private sign(x: number): number {\n        return x < 0 ? -1 : x > 0 ? 1 : 0;\n    }\n}\n"]}