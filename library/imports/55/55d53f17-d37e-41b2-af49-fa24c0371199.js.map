{"version":3,"sources":["../../../../assets/Script/assets/Script/CameraController.ts"],"names":[],"mappings":";;;;;;;;;;;;AAAA,uEAAgE;AAEhE,MAAM,EAAC,OAAO,EAAE,QAAQ,EAAC,GAAG,EAAE,CAAC,UAAU,CAAC;AAG1C,IAAqB,gBAAgB,GAArC,MAAqB,gBAAiB,SAAQ,EAAE,CAAC,SAAS;IAD1D;;QAGI,WAAM,GAAY,IAAI,CAAC;QAGvB,YAAO,GAAW,IAAI,CAAC,CAAC,iDAAiD;QAGzE,yBAAoB,GAAyB,IAAI,CAAC;IAwBtD,CAAC;IAtBG,MAAM,CAAC,EAAU;QACb,IAAI,CAAC,IAAI,CAAC,MAAM;YAAE,OAAO;QAEzB,4DAA4D;QAC5D,IAAI,YAAY,GAAG,IAAI,CAAC,oBAAoB,CAAC,YAAY,CAAC;QAC1D,IAAI,IAAI,GAAG,YAAY,CAAC,IAAI,GAAG,IAAI,CAAC,OAAO,CAAC;QAC5C,IAAI,IAAI,GAAG,YAAY,CAAC,IAAI,GAAG,IAAI,CAAC,OAAO,CAAC;QAE5C,+CAA+C;QAC/C,IAAI,cAAc,GAAG,IAAI,CAAC,MAAM,CAAC,qBAAqB,CAAC,EAAE,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC;QACrE,4EAA4E;QAC5E,IAAI,cAAc,GAAG,IAAI,CAAC,IAAI,CAAC,MAAM,CAAC,oBAAoB,CAAC,cAAc,CAAC,CAAC;QAE3E,iEAAiE;QACjE,IAAI,QAAQ,GAAG,EAAE,CAAC,IAAI,CAAC,MAAM,CAAC,cAAc,CAAC,CAAC,EAAE,IAAI,EAAE,IAAI,CAAC,CAAC;QAE5D,0EAA0E;QAC1E,IAAI,IAAI,GAAG,cAAc,CAAC,CAAC,CAAC;QAE5B,+BAA+B;QAC/B,IAAI,CAAC,IAAI,CAAC,QAAQ,GAAG,IAAI,EAAE,CAAC,IAAI,CAAC,QAAQ,EAAE,IAAI,CAAC,CAAC;IACrD,CAAC;CACJ,CAAA;AA9BG;IADC,QAAQ,CAAC,EAAE,CAAC,IAAI,CAAC;gDACK;AAGvB;IADC,QAAQ;iDACc;AAGvB;IADC,QAAQ,CAAC,8BAAoB,CAAC;8DACmB;AARjC,gBAAgB;IADpC,OAAO;GACa,gBAAgB,CAgCpC;kBAhCoB,gBAAgB","file":"","sourceRoot":"../../../../assets/Script","sourcesContent":["import WaterBoundarySetting from \"../Data/WaterBoundarySetting\";\n\nconst {ccclass, property} = cc._decorator;\n\n@ccclass\nexport default class CameraController extends cc.Component {\n    @property(cc.Node)\n    target: cc.Node = null;\n\n    @property\n    offsetX: number = 1000; // Adjust as needed for left and right boundaries\n\n    @property(WaterBoundarySetting)\n    waterBoundarySetting: WaterBoundarySetting = null;\n\n    update(dt: number): void {\n        if (!this.target) return;\n\n        // Calculate the camera's horizontal boundaries with offsets\n        let boundaryRect = this.waterBoundarySetting.boundaryRect;\n        let minX = boundaryRect.xMin + this.offsetX;\n        let maxX = boundaryRect.xMax - this.offsetX;\n\n        // Get the target's position in the world space\n        let targetWorldPos = this.target.convertToWorldSpaceAR(cc.Vec2.ZERO);\n        // Convert target's world position to the node (camera's parent) local space\n        let targetLocalPos = this.node.parent.convertToNodeSpaceAR(targetWorldPos);\n\n        // Clamp target's X position to keep within horizontal boundaries\n        let clampedX = cc.misc.clampf(targetLocalPos.x, minX, maxX);\n\n        // Y position follows the target directly, allowing free vertical movement\n        let newY = targetLocalPos.y;\n\n        // Update the camera's position\n        this.node.position = new cc.Vec2(clampedX, newY);\n    }\n}\n"]}