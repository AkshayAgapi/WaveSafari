{"version":3,"sources":["../../../../assets/Data/assets/Data/WaterBoundarySetting.ts"],"names":[],"mappings":"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","file":"","sourceRoot":"../../../../assets/Data","sourcesContent":["const { ccclass, property } = cc._decorator;\n\n\n@ccclass\nexport default class NewClass extends cc.Component {\n   @property(cc.Rect)\n   boundaryRect: cc.Rect = new cc.Rect(-500, -500, 1000, 1000);\n\n\n   private graphics: cc.Graphics = null;\n\n\n   onLoad() {\n       // Ensure debugGraphics is initialized\n       this.graphics = this.node.getComponent(cc.Graphics);\n       if (!this.graphics) {\n           this.graphics = this.node.addComponent(cc.Graphics);\n       }\n\n\n       // Draw dotted line around the boundaryRect\n       this.drawDottedRect(this.boundaryRect, 150);\n   }\n\n\n   drawDottedRect(rect: cc.Rect, offset: number) {\n    if (!this.graphics) return;\n\n    const segmentLength = 50; // Length of each segment\n\n    // Set line style for semi-transparent strokes\n    this.graphics.lineWidth = 8;\n    this.graphics.strokeColor = new cc.Color(0, 0, 0, 50); // Semi-transparent black\n\n    // Draw top side\n    for (let i = rect.xMin - offset; i < rect.xMax + offset; i += segmentLength * 2) {\n        this.graphics.moveTo(i, rect.yMin - offset);\n        this.graphics.lineTo(i + segmentLength, rect.yMin - offset);\n    }\n\n    // Draw right side\n    for (let i = rect.yMin - offset; i < rect.yMax + offset; i += segmentLength * 2) {\n        this.graphics.moveTo(rect.xMax + offset, i);\n        this.graphics.lineTo(rect.xMax + offset, i + segmentLength);\n    }\n\n    // Draw bottom side\n    for (let i = rect.xMax + offset; i > rect.xMin - offset; i -= segmentLength * 2) {\n        this.graphics.moveTo(i, rect.yMax + offset);\n        this.graphics.lineTo(i - segmentLength, rect.yMax + offset);\n    }\n\n    // Draw left side\n    for (let i = rect.yMax + offset; i > rect.yMin - offset; i -= segmentLength * 2) {\n        this.graphics.moveTo(rect.xMin - offset, i);\n        this.graphics.lineTo(rect.xMin - offset, i - segmentLength);\n    }\n\n    // Stroke path\n    this.graphics.stroke();\n   }\n  \n}\n"]}