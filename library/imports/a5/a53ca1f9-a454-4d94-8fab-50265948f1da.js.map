{"version":3,"sources":["../../../../assets/Script/assets/Script/LetterGenerator.ts"],"names":[],"mappings":";;;;;;AAAA,qCAAgC;AAE1B,IAAA,kBAAqC,EAAnC,oBAAO,EAAE,sBAA0B,CAAC;AAE5C;IAMI,yBAAY,MAAiB,EAAE,YAAqB,EAAE,WAAmB,EAAE,YAAoB;QAC3F,IAAI,CAAC,MAAM,GAAG,MAAM,CAAC;QACrB,IAAI,CAAC,YAAY,GAAG,YAAY,CAAC;QACjC,IAAI,CAAC,WAAW,GAAG,WAAW,CAAC;QAC/B,IAAI,CAAC,YAAY,GAAG,YAAY,CAAC;IACrC,CAAC;IAEM,yCAAe,GAAtB,UAAuB,IAAY;QAC/B,IAAI,OAAO,GAAG,CAAC,CAAC;QAEhB,0CAA0C;QAC1C,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,IAAI,CAAC,MAAM,EAAE,CAAC,EAAE,EAAE;YAClC,iDAAiD;YACjD,IAAM,QAAQ,GAAG,IAAI,CAAC,iBAAiB,EAAE,CAAC;YAE1C,4CAA4C;YAC5C,IAAI,CAAC,IAAI,CAAC,WAAW,CAAC,QAAQ,CAAC,EAAE;gBAC7B,gDAAgD;gBAChD,IAAM,UAAU,GAAG,EAAE,CAAC,WAAW,CAAC,IAAI,CAAC,MAAM,CAAC,CAAC;gBAC/C,IAAM,OAAO,GAAG,UAAU,CAAC,YAAY,CAAC,iBAAO,CAAC,CAAA;gBAChD,OAAO,CAAC,OAAO,CAAC,IAAI,CAAC,CAAC,CAAC,CAAC,CAAC;gBACzB,EAAE,CAAC,MAAM,CAAC,QAAQ,CAAC,IAAI,CAAC,QAAQ,CAAC,UAAU,CAAC,CAAC;gBAC7C,UAAU,CAAC,QAAQ,GAAG,QAAQ,CAAC;aAClC;YAED,sCAAsC;YACtC,OAAO,IAAI,IAAI,CAAC,WAAW,CAAC;SAC/B;IACL,CAAC;IAEO,2CAAiB,GAAzB;QACI,0DAA0D;QAC1D,IAAM,CAAC,GAAG,IAAI,CAAC,cAAc,CAAC,IAAI,CAAC,YAAY,CAAC,IAAI,EAAE,IAAI,CAAC,YAAY,CAAC,IAAI,CAAC,CAAC;QAC9E,IAAM,CAAC,GAAG,IAAI,CAAC,cAAc,CAAC,IAAI,CAAC,YAAY,CAAC,IAAI,EAAE,IAAI,CAAC,YAAY,CAAC,IAAI,CAAC,CAAC;QAC9E,OAAO,IAAI,EAAE,CAAC,IAAI,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC;IAC7B,CAAC;IAEO,qCAAW,GAAnB,UAAoB,QAAiB;QACjC,yCAAyC;QACzC,2DAA2D;QAE3D,iEAAiE;QACjE,OAAO,KAAK,CAAC;IACjB,CAAC;IAEO,wCAAc,GAAtB,UAAuB,GAAW,EAAE,GAAW;QAC3C,OAAO,IAAI,CAAC,KAAK,CAAC,IAAI,CAAC,MAAM,EAAE,GAAG,CAAC,GAAG,GAAG,GAAG,GAAG,CAAC,CAAC,CAAC,GAAG,GAAG,CAAC;IAC7D,CAAC;IACL,sBAAC;AAAD,CAtDA,AAsDC,IAAA","file":"","sourceRoot":"../../../../assets/Script","sourcesContent":["import PathHub from \"./PathHub\";\n\nconst { ccclass, property } = cc._decorator;\n\nexport default class LetterGenerator {\n    private prefab: cc.Prefab;\n    private boundaryRect: cc.Rect;\n    private letterWidth: number;\n    private letterHeight: number;\n\n    constructor(prefab: cc.Prefab, boundaryRect: cc.Rect, letterWidth: number, letterHeight: number) {\n        this.prefab = prefab;\n        this.boundaryRect = boundaryRect;\n        this.letterWidth = letterWidth;\n        this.letterHeight = letterHeight;\n    }\n\n    public generateLetters(word: string): void {\n        let xOffset = 0;\n\n        // Loop through each character in the word\n        for (let i = 0; i < word.length; i++) {\n            // Randomly select a position within the boundary\n            const position = this.getRandomPosition();\n\n            // Check for collision with existing letters\n            if (!this.isColliding(position)) {\n                // Instantiate the letter prefab at the position\n                const letterNode = cc.instantiate(this.prefab);\n                const pathHub = letterNode.getComponent(PathHub)\n                pathHub.setData(word[i]);\n                cc.Canvas.instance.node.addChild(letterNode);\n                letterNode.position = position;\n            }\n\n            // Update x-offset for the next letter\n            xOffset += this.letterWidth;\n        }\n    }\n\n    private getRandomPosition(): cc.Vec2 {\n        // Generate random x and y coordinates within the boundary\n        const x = this.getRandomRange(this.boundaryRect.xMin, this.boundaryRect.xMax);\n        const y = this.getRandomRange(this.boundaryRect.yMin, this.boundaryRect.yMax);\n        return new cc.Vec2(x, y);\n    }\n\n    private isColliding(position: cc.Vec2): boolean {\n        // Perform collision detection logic here\n        // Check if the new position collides with existing letters\n\n        // For demonstration purposes, always return false (no collision)\n        return false;\n    }\n\n    private getRandomRange(min: number, max: number): number {\n        return Math.floor(Math.random() * (max - min + 1)) + min;\n    }\n}\n"]}